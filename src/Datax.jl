module Datax
using  Requires, Formatting

export datax,@datax

# TODO: use printf

"""
```julia
datax(...)
```
Print the arguments to a file readable by pgfkeys (Best for use with the `datax` LaTeX
package). A string will be printed as is, a number will be wrapped in `siunitx`'s
`\\num`, and a tuple `(value::Number, unit::String)` or a `Unitful` quantity will be wrapped in `\\SI`.
If the argument is a `Tuple` and the first argument is a string, it is used as a format
string for the rest of the tuple.
There's also a macro form, `@datax`, which reuses the variable names from the script.


# Examples
```julia
datax(a=2,b=1.24,c="hi",d=(24,"\\meter"),e=15u"kg/s^2")
```
Save the given variables in siunitx form
"""
function datax(;kwargs...)
    datax(Dict(kwargs))
end

function datax(d::Dict{Symbol,<:Any};filename::String="data.tex",format::String="%.4g")
    open(filename,"w") do f
        println(f,"% Autogenerated by Datax.jl, will be overwritten")
        for (k,v) in d
            print(f,"\\pgfkeyssetvalue{/datax/$k}{")
            printdata(f,v,format)
            print(f,"}\n")
        end
    end
end

"""
```julia
@datax ...
```
Print the arguments to a file readable by pgfkeys (Best for use with the `datax` LaTeX package)
Like the `datax()` function, but use the variables' names.

# Examples
```julia
a=2;
b=3.2u"m"
c="hi"
@datax a b c
```
"""
macro datax(args...)
    esc(datax_helper(args...))
end
function datax_helper(args...)
    names = Expr(:vect, QuoteNode.(args)...)
    values = Expr(:vect, args...)
    quote
        datax(Dict($names .=> $values))
    end
end

printdata(f::IO,v::String,fmt::String) = print(f,v)
printdata(f::IO,v::Number,fmt::String) = print(f,"\\num{"*sprintf1(fmt,v)*"}")
printdata(f::IO,v::Tuple{<:Number,String},fmt::String) = print(f,"\\SI{"*sprintf1(fmt,v[1])*"}{"*v[2]*"}")
printdata(f::IO,v::Tuple{String,Vararg},fmt::String) = printdata(f,length(v)>2 ? v[2:end] : v[2], v[1])

function __init__()
    @require Unitful="1986cc42-f94f-5a68-af5c-568840ba703d" begin

        function printdata(f::IO,v::Unitful.Quantity,fmt::String)
            print(f,"\\SI{"*sprintf1(fmt,v.val)*"}{")
            siunitxprint(f,Unitful.unit(v))
            print(f,"}")
        end

        function siunitxprint(f::IO,u::Unitful.FreeUnits)
            prefixes = Dict(
                            -24 => "\\yocto",
                            -21 => "\\zepto",
                            -18 => "\\atto",
                            -15 => "\\femto",
                            -12 => "\\pico",
                            -9  => "\\nano",
                            -6  => "\\micro",
                            -3  => "\\milli",
                            -2  => "\\centi",
                            -1  => "\\deci",
                            0   => "",
                            1   => "\\deka",
                            2   => "\\hecto",
                            3   => "\\kilo",
                            6   => "\\mega",
                            9   => "\\giga",
                            12  => "\\tera",
                            15  => "\\peta",
                            18  => "\\exa",
                            21  => "\\zetta",
                            24  => "\\yotta"
                           )
            for p in typeof(u).parameters[1]
                p.power<0 && print(f,"\\per")
                iszero(p.tens) || print(f,prefixes[p.tens])
                print(f,"\\$(lowercase(String(Unitful.name(p))))")
                abs(p.power)==1 || print(f,"\\tothe$(Int64(abs(p.power)))")
            end
        end

    end
end

                                                           end # module
