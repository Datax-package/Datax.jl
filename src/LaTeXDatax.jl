module LaTeXDatax
using  Requires, Formatting

export datax,@datax

"""
```julia
datax(...)
```

Print the arguments to a file readable by pgfkeys (Best for use with the
`datax` LaTeX package). A string will be printed as is, a number will be
wrapped in `siunitx`'s `\\num`, and a tuple `(value::Number, unit::String)` or
a `Unitful` quantity will be wrapped in `\\SI`.  If the argument is a `Tuple`
and the first argument is a string, it is used as a format string for the rest
of the tuple.  There's also a macro form, `@datax`, which reuses the variable
names from the script.

The variable name "filename" cannot be stored, but will instead be used as the
name of the file to store.

# Examples
```julia
datax(a=2,b=1.24,c="hi",d=(24,"\\meter"),e=15u"kg/s^2")
```
Save the given variables in siunitx form.

```julia
datax(lambda=612.2u"nm",filename="other.tex")
"""
function datax(;filename="data.tex",kwargs...)
    datax(Dict(kwargs),filename=filename)
end

function datax(d::Dict{Symbol,<:Any};filename="data.tex",format::String="%.4g")
    open(filename,"w") do f
        println(f,"% Autogenerated by LaTeXDatax.jl, will be overwritten")
        for (k,v) in d
            print(f,"\\pgfkeyssetvalue{/datax/$k}{")
            printdata(f,v,format)
            print(f,"}\n")
        end
    end
end

"""
```julia
@datax ...
```
Print the arguments to a file readable by pgfkeys (Best for use with the
`datax` LaTeX package) Like the `datax()` function, but use the variables'
names.

# Examples
```julia
a=2;
b=3.2u"m"
c="hi"
filename="datafile.tex"
@datax a b c filename
```
"""
macro datax(args...)
    esc(datax_helper(args...))
end
function datax_helper(filname="data.tex",args...)
    names = Expr(:vect, QuoteNode.(args)...)
    values = Expr(:vect, args...)
    quote
        datax(Dict($names .=> $values),filename=filename)
    end
end

printdata(f::IO,v::String,fmt::String) = print(f,v)
printdata(f::IO,v::Number,fmt::String) = print(f,"\\num{"*sprintf1(fmt,v)*"}")
printdata(f::IO,v::AbstractArray{<:Number},fmt::String) = print(f,"\\numlist{"*prod(sprintf1.(fmt,v).*";")*"}")
printdata(f::IO,v::Tuple{<:Number,String},fmt::String) = print(f,"\\SI{"*sprintf1(fmt,v[1])*"}{"*v[2]*"}")
printdata(f::IO,v::Tuple{AbstractArray{<:Number},String},fmt::String) = print(f,"\\SIlist{"*prod(sprintf1.(fmt,v[1]).*";")*"}{"*v[2]*"}")
printdata(f::IO,v::Tuple{String,Vararg},fmt::String) = printdata(f,length(v)>2 ? v[2:end] : v[2], v[1])

function __init__()
    @require Unitful="1986cc42-f94f-5a68-af5c-568840ba703d" begin

        function printdata(f::IO,v::Unitful.Quantity,fmt::String)
            print(f,"\\SI{"*sprintf1(fmt,v.val)*"}{")
            siunitxprint(f,Unitful.unit(v))
            print(f,"}")
        end
        function printdata(f::IO,v::AbstractArray{T},fmt::String) where T<:Unitful.Quantity
            print(f,"\\SIlist{"*prod(sprintf1.(fmt,Unitful.ustrip(v)).*";")*"}{")
            siunitxprint(f,Unitful.unit(T))
            print(f,"}")
        end

        function siunitxprint(f::IO,u::Unitful.FreeUnits)
            prefixes = Dict(
                            -24 => "\\yocto",
                            -21 => "\\zepto",
                            -18 => "\\atto",
                            -15 => "\\femto",
                            -12 => "\\pico",
                            -9  => "\\nano",
                            -6  => "\\micro",
                            -3  => "\\milli",
                            -2  => "\\centi",
                            -1  => "\\deci",
                            0   => "",
                            1   => "\\deka",
                            2   => "\\hecto",
                            3   => "\\kilo",
                            6   => "\\mega",
                            9   => "\\giga",
                            12  => "\\tera",
                            15  => "\\peta",
                            18  => "\\exa",
                            21  => "\\zetta",
                            24  => "\\yotta"
                           )
            for p in typeof(u).parameters[1]
                p.power<0 && print(f,"\\per")
                iszero(p.tens) || print(f,prefixes[p.tens])
                print(f,"\\$(lowercase(String(Unitful.name(p))))")
                abs(p.power)==1 || print(f,"\\tothe$(Int64(abs(p.power)))")
            end
        end

    end
end

end # module
